// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chaincode.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/Timestamp.pbobjc.h>
#else
 #import "google/protobuf/Timestamp.pbobjc.h"
#endif

 #import "Chaincode.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ChaincodeRoot

@implementation ChaincodeRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ChaincodeRoot_FileDescriptor

static GPBFileDescriptor *ChaincodeRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"protos"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum ConfidentialityLevel

GPBEnumDescriptor *ConfidentialityLevel_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Public\000Confidential\000";
    static const int32_t values[] = {
        ConfidentialityLevel_Public,
        ConfidentialityLevel_Confidential,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ConfidentialityLevel)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ConfidentialityLevel_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ConfidentialityLevel_IsValidValue(int32_t value__) {
  switch (value__) {
    case ConfidentialityLevel_Public:
    case ConfidentialityLevel_Confidential:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ChaincodeID

@implementation ChaincodeID

@dynamic path;
@dynamic name;
@dynamic version;

typedef struct ChaincodeID__storage_ {
  uint32_t _has_storage_[1];
  NSString *path;
  NSString *name;
  NSString *version;
} ChaincodeID__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "path",
        .dataTypeSpecific.className = NULL,
        .number = ChaincodeID_FieldNumber_Path,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChaincodeID__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ChaincodeID_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChaincodeID__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = ChaincodeID_FieldNumber_Version,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChaincodeID__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChaincodeID class]
                                     rootClass:[ChaincodeRoot class]
                                          file:ChaincodeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChaincodeID__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChaincodeInput

@implementation ChaincodeInput

@dynamic argsArray, argsArray_Count;

typedef struct ChaincodeInput__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *argsArray;
} ChaincodeInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "argsArray",
        .dataTypeSpecific.className = NULL,
        .number = ChaincodeInput_FieldNumber_ArgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChaincodeInput__storage_, argsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChaincodeInput class]
                                     rootClass:[ChaincodeRoot class]
                                          file:ChaincodeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChaincodeInput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChaincodeSpec

@implementation ChaincodeSpec

@dynamic type;
@dynamic hasChaincodeId, chaincodeId;
@dynamic hasInput, input;
@dynamic timeout;

typedef struct ChaincodeSpec__storage_ {
  uint32_t _has_storage_[1];
  ChaincodeSpec_Type type;
  int32_t timeout;
  ChaincodeID *chaincodeId;
  ChaincodeInput *input;
} ChaincodeSpec__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ChaincodeSpec_Type_EnumDescriptor,
        .number = ChaincodeSpec_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChaincodeSpec__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "chaincodeId",
        .dataTypeSpecific.className = GPBStringifySymbol(ChaincodeID),
        .number = ChaincodeSpec_FieldNumber_ChaincodeId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChaincodeSpec__storage_, chaincodeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "input",
        .dataTypeSpecific.className = GPBStringifySymbol(ChaincodeInput),
        .number = ChaincodeSpec_FieldNumber_Input,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChaincodeSpec__storage_, input),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timeout",
        .dataTypeSpecific.className = NULL,
        .number = ChaincodeSpec_FieldNumber_Timeout,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChaincodeSpec__storage_, timeout),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChaincodeSpec class]
                                     rootClass:[ChaincodeRoot class]
                                          file:ChaincodeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChaincodeSpec__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ChaincodeSpec_Type_RawValue(ChaincodeSpec *message) {
  GPBDescriptor *descriptor = [ChaincodeSpec descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChaincodeSpec_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetChaincodeSpec_Type_RawValue(ChaincodeSpec *message, int32_t value) {
  GPBDescriptor *descriptor = [ChaincodeSpec descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChaincodeSpec_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum ChaincodeSpec_Type

GPBEnumDescriptor *ChaincodeSpec_Type_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Undefined\000Golang\000Node\000Car\000Java\000";
    static const int32_t values[] = {
        ChaincodeSpec_Type_Undefined,
        ChaincodeSpec_Type_Golang,
        ChaincodeSpec_Type_Node,
        ChaincodeSpec_Type_Car,
        ChaincodeSpec_Type_Java,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChaincodeSpec_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChaincodeSpec_Type_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChaincodeSpec_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChaincodeSpec_Type_Undefined:
    case ChaincodeSpec_Type_Golang:
    case ChaincodeSpec_Type_Node:
    case ChaincodeSpec_Type_Car:
    case ChaincodeSpec_Type_Java:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SenderSpec

@implementation SenderSpec

@dynamic sender;
@dynamic counter;
@dynamic inkLimit;
@dynamic msg;

typedef struct SenderSpec__storage_ {
  uint32_t _has_storage_[1];
  NSData *sender;
  NSData *inkLimit;
  NSData *msg;
  uint64_t counter;
} SenderSpec__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sender",
        .dataTypeSpecific.className = NULL,
        .number = SenderSpec_FieldNumber_Sender,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SenderSpec__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "counter",
        .dataTypeSpecific.className = NULL,
        .number = SenderSpec_FieldNumber_Counter,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SenderSpec__storage_, counter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "inkLimit",
        .dataTypeSpecific.className = NULL,
        .number = SenderSpec_FieldNumber_InkLimit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SenderSpec__storage_, inkLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = SenderSpec_FieldNumber_Msg,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SenderSpec__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SenderSpec class]
                                     rootClass:[ChaincodeRoot class]
                                          file:ChaincodeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SenderSpec__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SignContent

@implementation SignContent

@dynamic hasChaincodeSpec, chaincodeSpec;
@dynamic idGenerationAlg;
@dynamic hasSenderSpec, senderSpec;

typedef struct SignContent__storage_ {
  uint32_t _has_storage_[1];
  ChaincodeSpec *chaincodeSpec;
  NSString *idGenerationAlg;
  SenderSpec *senderSpec;
} SignContent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chaincodeSpec",
        .dataTypeSpecific.className = GPBStringifySymbol(ChaincodeSpec),
        .number = SignContent_FieldNumber_ChaincodeSpec,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignContent__storage_, chaincodeSpec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "idGenerationAlg",
        .dataTypeSpecific.className = NULL,
        .number = SignContent_FieldNumber_IdGenerationAlg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SignContent__storage_, idGenerationAlg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "senderSpec",
        .dataTypeSpecific.className = GPBStringifySymbol(SenderSpec),
        .number = SignContent_FieldNumber_SenderSpec,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SignContent__storage_, senderSpec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignContent class]
                                     rootClass:[ChaincodeRoot class]
                                          file:ChaincodeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignContent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChaincodeDeploymentSpec

@implementation ChaincodeDeploymentSpec

@dynamic hasChaincodeSpec, chaincodeSpec;
@dynamic hasEffectiveDate, effectiveDate;
@dynamic codePackage;
@dynamic execEnv;

typedef struct ChaincodeDeploymentSpec__storage_ {
  uint32_t _has_storage_[1];
  ChaincodeDeploymentSpec_ExecutionEnvironment execEnv;
  ChaincodeSpec *chaincodeSpec;
  GPBTimestamp *effectiveDate;
  NSData *codePackage;
} ChaincodeDeploymentSpec__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chaincodeSpec",
        .dataTypeSpecific.className = GPBStringifySymbol(ChaincodeSpec),
        .number = ChaincodeDeploymentSpec_FieldNumber_ChaincodeSpec,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChaincodeDeploymentSpec__storage_, chaincodeSpec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "effectiveDate",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = ChaincodeDeploymentSpec_FieldNumber_EffectiveDate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChaincodeDeploymentSpec__storage_, effectiveDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "codePackage",
        .dataTypeSpecific.className = NULL,
        .number = ChaincodeDeploymentSpec_FieldNumber_CodePackage,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChaincodeDeploymentSpec__storage_, codePackage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "execEnv",
        .dataTypeSpecific.enumDescFunc = ChaincodeDeploymentSpec_ExecutionEnvironment_EnumDescriptor,
        .number = ChaincodeDeploymentSpec_FieldNumber_ExecEnv,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChaincodeDeploymentSpec__storage_, execEnv),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChaincodeDeploymentSpec class]
                                     rootClass:[ChaincodeRoot class]
                                          file:ChaincodeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChaincodeDeploymentSpec__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ChaincodeDeploymentSpec_ExecEnv_RawValue(ChaincodeDeploymentSpec *message) {
  GPBDescriptor *descriptor = [ChaincodeDeploymentSpec descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChaincodeDeploymentSpec_FieldNumber_ExecEnv];
  return GPBGetMessageInt32Field(message, field);
}

void SetChaincodeDeploymentSpec_ExecEnv_RawValue(ChaincodeDeploymentSpec *message, int32_t value) {
  GPBDescriptor *descriptor = [ChaincodeDeploymentSpec descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChaincodeDeploymentSpec_FieldNumber_ExecEnv];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum ChaincodeDeploymentSpec_ExecutionEnvironment

GPBEnumDescriptor *ChaincodeDeploymentSpec_ExecutionEnvironment_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Docker\000System\000";
    static const int32_t values[] = {
        ChaincodeDeploymentSpec_ExecutionEnvironment_Docker,
        ChaincodeDeploymentSpec_ExecutionEnvironment_System,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChaincodeDeploymentSpec_ExecutionEnvironment)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChaincodeDeploymentSpec_ExecutionEnvironment_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChaincodeDeploymentSpec_ExecutionEnvironment_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChaincodeDeploymentSpec_ExecutionEnvironment_Docker:
    case ChaincodeDeploymentSpec_ExecutionEnvironment_System:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ChaincodeInvocationSpec

@implementation ChaincodeInvocationSpec

@dynamic hasChaincodeSpec, chaincodeSpec;
@dynamic idGenerationAlg;
@dynamic hasSenderSpec, senderSpec;
@dynamic sig;

typedef struct ChaincodeInvocationSpec__storage_ {
  uint32_t _has_storage_[1];
  ChaincodeSpec *chaincodeSpec;
  NSString *idGenerationAlg;
  SenderSpec *senderSpec;
  NSData *sig;
} ChaincodeInvocationSpec__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chaincodeSpec",
        .dataTypeSpecific.className = GPBStringifySymbol(ChaincodeSpec),
        .number = ChaincodeInvocationSpec_FieldNumber_ChaincodeSpec,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChaincodeInvocationSpec__storage_, chaincodeSpec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "idGenerationAlg",
        .dataTypeSpecific.className = NULL,
        .number = ChaincodeInvocationSpec_FieldNumber_IdGenerationAlg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChaincodeInvocationSpec__storage_, idGenerationAlg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "senderSpec",
        .dataTypeSpecific.className = GPBStringifySymbol(SenderSpec),
        .number = ChaincodeInvocationSpec_FieldNumber_SenderSpec,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChaincodeInvocationSpec__storage_, senderSpec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sig",
        .dataTypeSpecific.className = NULL,
        .number = ChaincodeInvocationSpec_FieldNumber_Sig,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChaincodeInvocationSpec__storage_, sig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChaincodeInvocationSpec class]
                                     rootClass:[ChaincodeRoot class]
                                          file:ChaincodeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChaincodeInvocationSpec__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
